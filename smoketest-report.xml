<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="1" skipped="0" tests="4" time="30.367" timestamp="2022-06-28T17:35:13.127082" hostname="Ellens-MacBook-Pro.local"><testcase classname="tests.api_tests" name="test_output_test_config" time="0.000" /><testcase classname="tests.api_tests" name="test_wait_for_ping" time="0.161" /><testcase classname="tests.api_tests" name="test_check_status_is_secured" time="0.117" /><testcase classname="tests.api_tests" name="test_wait_for_status" time="30.004"><failure message="api_test_utils.PollTimeoutError: last status: 401&#10;last headers:&lt;CIMultiDictProxy('Date': 'Tue, 28 Jun 2022 16:35:46 GMT', 'Content-Type': 'application/json', 'Content-Length': '789', 'Connection': 'keep-alive', 'Strict-Transport-Security': 'max-age=864000; includeSubDomains')&gt;&#10;last body:{'resourceType': 'OperationOutcome', 'issue': [{'severity': 'error', 'code': 'unknown', 'details': {'coding': [{'system': 'https://fhir.nhs.uk/R4/CodeSystem/Spine-ErrorOrWarningCode', 'version': '1', 'code': 'UNKNOWN_ERROR', 'display': 'An unknown error occurred processing this request. Contact us for assistance diagnosing this issue: https://digital.nhs.uk/developer/help-and-support. (Message ID: rrt-3873145766307958687-b-geu2-4494-6372564-29)'}]}}]}">async def _poll_until():
    
        while True:
    
            async with make_request() as response:
    
                body = None
    
                if body_resolver is not None:
                    body = await body_resolver(response)
    
                responses.append((response.status, response.headers, body))
                should_stop = await until(response)
                if not should_stop:
&gt;                   await asyncio.sleep(sleep_for)

.venv/lib/python3.10/site-packages/api_test_utils/__init__.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

delay = 1, result = None

    async def sleep(delay, result=None):
        """Coroutine that completes after a given time (in seconds)."""
        if delay &lt;= 0:
            await __sleep0()
            return result
    
        loop = events.get_running_loop()
        future = loop.create_future()
        h = loop.call_later(delay,
                            futures._set_result_unless_cancelled,
                            future, result)
        try:
&gt;           return await future
E           asyncio.exceptions.CancelledError

/opt/homebrew/Cellar/python@3.10/3.10.4/Frameworks/Python.framework/Versions/3.10/lib/python3.10/asyncio/tasks.py:605: CancelledError

During handling of the above exception, another exception occurred:

fut = &lt;Task cancelled name='Task-14' coro=&lt;poll_until.&lt;locals&gt;._poll_until() done, defined at /Users/ellenwootten/Documents/src/NHSD-nia/spine-directory-service-api/.venv/lib/python3.10/site-packages/api_test_utils/__init__.py:118&gt;&gt;
timeout = 30

    async def wait_for(fut, timeout):
        """Wait for the single Future or coroutine to complete, with timeout.
    
        Coroutine will be wrapped in Task.
    
        Returns result of the Future or coroutine.  When a timeout occurs,
        it cancels the task and raises TimeoutError.  To avoid the task
        cancellation, wrap it in shield().
    
        If the wait is cancelled, the task is also cancelled.
    
        This function is a coroutine.
        """
        loop = events.get_running_loop()
    
        if timeout is None:
            return await fut
    
        if timeout &lt;= 0:
            fut = ensure_future(fut, loop=loop)
    
            if fut.done():
                return fut.result()
    
            await _cancel_and_wait(fut, loop=loop)
            try:
                return fut.result()
            except exceptions.CancelledError as exc:
                raise exceptions.TimeoutError() from exc
    
        waiter = loop.create_future()
        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)
        cb = functools.partial(_release_waiter, waiter)
    
        fut = ensure_future(fut, loop=loop)
        fut.add_done_callback(cb)
    
        try:
            # wait until the future completes or the timeout
            try:
                await waiter
            except exceptions.CancelledError:
                if fut.done():
                    return fut.result()
                else:
                    fut.remove_done_callback(cb)
                    # We must ensure that the task is not running
                    # after wait_for() returns.
                    # See https://bugs.python.org/issue32751
                    await _cancel_and_wait(fut, loop=loop)
                    raise
    
            if fut.done():
                return fut.result()
            else:
                fut.remove_done_callback(cb)
                # We must ensure that the task is not running
                # after wait_for() returns.
                # See https://bugs.python.org/issue32751
                await _cancel_and_wait(fut, loop=loop)
                # In case task cancellation failed with some
                # exception, we should re-raise it
                # See https://bugs.python.org/issue40607
                try:
&gt;                   return fut.result()
E                   asyncio.exceptions.CancelledError

/opt/homebrew/Cellar/python@3.10/3.10.4/Frameworks/Python.framework/Versions/3.10/lib/python3.10/asyncio/tasks.py:456: CancelledError

The above exception was the direct cause of the following exception:

make_request = &lt;function test_wait_for_status.&lt;locals&gt;.&lt;lambda&gt; at 0x105153c70&gt;, until = &lt;function test_wait_for_status.&lt;locals&gt;.is_deployed at 0x105152e60&gt;
body_resolver = &lt;function test_wait_for_status.&lt;locals&gt;.&lt;lambda&gt; at 0x105153d00&gt;, timeout = 30, sleep_for = 1

    async def poll_until(
        make_request: Callable[[], Awaitable[ClientResponse]],
        until: Callable[[ClientResponse], Awaitable[bool]] = is_200,
        body_resolver: Callable[[ClientResponse], Awaitable[Any]] = auto_load_body,
        timeout: int = 5,
        sleep_for: float = 1
    ):
        """
            repeat an api request until a specified condition is met or raise a timeout
        Args:
            make_request: request factory, e.g. lambda: session.get('http://test.com')
            until: predicate to evaluate the response ,  e.g. lambda r: r.status == 404
            body_resolver: factory to resolve the body (evaluated on every response for tracking responses)
                            e.g.  lambda r: await r.body()
                            set to None not to retrieve the body, obviously retrieving the body will potentially have an
                            overhead, and attempt to parse or load invalid responses will break the polling
    
            timeout: timeout in seconds
            sleep_for: poll frequency in seconds
    
        Returns:
            List[Tuple[int, IMultiDictProxy, Any]]: responses received, (status, headers, body)
        """
    
        responses = []
    
        async def _poll_until():
    
            while True:
    
                async with make_request() as response:
    
                    body = None
    
                    if body_resolver is not None:
                        body = await body_resolver(response)
    
                    responses.append((response.status, response.headers, body))
                    should_stop = await until(response)
                    if not should_stop:
                        await asyncio.sleep(sleep_for)
                        continue
    
                    return responses
    
        try:
&gt;           return await asyncio.wait_for(_poll_until(), timeout=timeout)

.venv/lib/python3.10/site-packages/api_test_utils/__init__.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fut = &lt;Task cancelled name='Task-14' coro=&lt;poll_until.&lt;locals&gt;._poll_until() done, defined at /Users/ellenwootten/Documents/src/NHSD-nia/spine-directory-service-api/.venv/lib/python3.10/site-packages/api_test_utils/__init__.py:118&gt;&gt;
timeout = 30

    async def wait_for(fut, timeout):
        """Wait for the single Future or coroutine to complete, with timeout.
    
        Coroutine will be wrapped in Task.
    
        Returns result of the Future or coroutine.  When a timeout occurs,
        it cancels the task and raises TimeoutError.  To avoid the task
        cancellation, wrap it in shield().
    
        If the wait is cancelled, the task is also cancelled.
    
        This function is a coroutine.
        """
        loop = events.get_running_loop()
    
        if timeout is None:
            return await fut
    
        if timeout &lt;= 0:
            fut = ensure_future(fut, loop=loop)
    
            if fut.done():
                return fut.result()
    
            await _cancel_and_wait(fut, loop=loop)
            try:
                return fut.result()
            except exceptions.CancelledError as exc:
                raise exceptions.TimeoutError() from exc
    
        waiter = loop.create_future()
        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)
        cb = functools.partial(_release_waiter, waiter)
    
        fut = ensure_future(fut, loop=loop)
        fut.add_done_callback(cb)
    
        try:
            # wait until the future completes or the timeout
            try:
                await waiter
            except exceptions.CancelledError:
                if fut.done():
                    return fut.result()
                else:
                    fut.remove_done_callback(cb)
                    # We must ensure that the task is not running
                    # after wait_for() returns.
                    # See https://bugs.python.org/issue32751
                    await _cancel_and_wait(fut, loop=loop)
                    raise
    
            if fut.done():
                return fut.result()
            else:
                fut.remove_done_callback(cb)
                # We must ensure that the task is not running
                # after wait_for() returns.
                # See https://bugs.python.org/issue32751
                await _cancel_and_wait(fut, loop=loop)
                # In case task cancellation failed with some
                # exception, we should re-raise it
                # See https://bugs.python.org/issue40607
                try:
                    return fut.result()
                except exceptions.CancelledError as exc:
&gt;                   raise exceptions.TimeoutError() from exc
E                   asyncio.exceptions.TimeoutError

/opt/homebrew/Cellar/python@3.10/3.10.4/Frameworks/Python.framework/Versions/3.10/lib/python3.10/asyncio/tasks.py:458: TimeoutError

The above exception was the direct cause of the following exception:

api_client = &lt;api_test_utils.api_session_client.APISessionClient object at 0x105173340&gt;
api_test_config = APITestSessionConfig(base_uri='https://internal-dev.api.service.nhs.uk/spine-directory/FHIR/R4', api_environment='internal-dev', commit_id='2f6601df1b429472e01c9669c50b9cd0bc47f609')

    @pytest.mark.e2e
    @pytest.mark.smoketest
    @pytest.mark.asyncio
    async def test_wait_for_status(api_client: APISessionClient, api_test_config: APITestSessionConfig):
        async def is_deployed(resp: ClientResponse):
            if resp.status != 200:
                return False
    
            body = await resp.json()
    
            if body.get("commitId") != api_test_config.commit_id:
                return False
    
            backend = _dict_path(body, ["checks", "healthcheck", "outcome", "version"])
            if not backend:
                return True
    
            return backend.get("commitId") == api_test_config.commit_id
    
        deploy_timeout = 120 if api_test_config.api_environment.endswith("sandbox") else 30
    
&gt;       responses = await poll_until(
            make_request=lambda: api_client.get(
                "_status", headers={"apikey": env.status_endpoint_api_key()}
            ),
            until=is_deployed,
            body_resolver=lambda r: r.json(),
            timeout=deploy_timeout,
        )

tests/api_tests.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

make_request = &lt;function test_wait_for_status.&lt;locals&gt;.&lt;lambda&gt; at 0x105153c70&gt;, until = &lt;function test_wait_for_status.&lt;locals&gt;.is_deployed at 0x105152e60&gt;
body_resolver = &lt;function test_wait_for_status.&lt;locals&gt;.&lt;lambda&gt; at 0x105153d00&gt;, timeout = 30, sleep_for = 1

    async def poll_until(
        make_request: Callable[[], Awaitable[ClientResponse]],
        until: Callable[[ClientResponse], Awaitable[bool]] = is_200,
        body_resolver: Callable[[ClientResponse], Awaitable[Any]] = auto_load_body,
        timeout: int = 5,
        sleep_for: float = 1
    ):
        """
            repeat an api request until a specified condition is met or raise a timeout
        Args:
            make_request: request factory, e.g. lambda: session.get('http://test.com')
            until: predicate to evaluate the response ,  e.g. lambda r: r.status == 404
            body_resolver: factory to resolve the body (evaluated on every response for tracking responses)
                            e.g.  lambda r: await r.body()
                            set to None not to retrieve the body, obviously retrieving the body will potentially have an
                            overhead, and attempt to parse or load invalid responses will break the polling
    
            timeout: timeout in seconds
            sleep_for: poll frequency in seconds
    
        Returns:
            List[Tuple[int, IMultiDictProxy, Any]]: responses received, (status, headers, body)
        """
    
        responses = []
    
        async def _poll_until():
    
            while True:
    
                async with make_request() as response:
    
                    body = None
    
                    if body_resolver is not None:
                        body = await body_resolver(response)
    
                    responses.append((response.status, response.headers, body))
                    should_stop = await until(response)
                    if not should_stop:
                        await asyncio.sleep(sleep_for)
                        continue
    
                    return responses
    
        try:
            return await asyncio.wait_for(_poll_until(), timeout=timeout)
        except asyncio.TimeoutError as e:
&gt;           raise PollTimeoutError(responses) from e
E           api_test_utils.PollTimeoutError: last status: 401
E           last headers:&lt;CIMultiDictProxy('Date': 'Tue, 28 Jun 2022 16:35:46 GMT', 'Content-Type': 'application/json', 'Content-Length': '789', 'Connection': 'keep-alive', 'Strict-Transport-Security': 'max-age=864000; includeSubDomains')&gt;
E           last body:{'resourceType': 'OperationOutcome', 'issue': [{'severity': 'error', 'code': 'unknown', 'details': {'coding': [{'system': 'https://fhir.nhs.uk/R4/CodeSystem/Spine-ErrorOrWarningCode', 'version': '1', 'code': 'UNKNOWN_ERROR', 'display': 'An unknown error occurred processing this request. Contact us for assistance diagnosing this issue: https://digital.nhs.uk/developer/help-and-support. (Message ID: rrt-3873145766307958687-b-geu2-4494-6372564-29)'}]}}]}

.venv/lib/python3.10/site-packages/api_test_utils/__init__.py:140: PollTimeoutError</failure></testcase></testsuite></testsuites>